!function (e) { "use strict"; function a (e, a, t, s) { const r = a._carduse_skill.target.call(a._carduse_skill, e, t.from, a._use_or_play_vcard.vdata), n = s ?? { type: "player" }; return n.step = 9, n.excluesDeath = n.excluesDeath ?? r.excluesDeath ?? !0, n.count = n.count ?? r.count, n.auto = n.auto ?? r.auto, n.canConfirm = n.canConfirm ?? r.canConfirm, n.filter = function (e, a) { return t.from.canUseCard(this._use_or_play_vcard.vdata, [e], "", s, a) }, n.onChange = function (e, a) { r.onChange?.call(this, e, a), s?.onChange?.call(this, e, a) }, n } const t = sgs.TriggerEffect({ name: "base_selectors", priorityType: 0, getSelectors: (e, t) => ({ use_card: () => function (e, t) { const s = t.from; if (!s) return { selectors: {}, options: {} }; t.options || (t.options = {}); let r = t.options.prompt; if (!t.options.prompt && t.can_use_cards?.length > 0) { const a = e.getCardUse(t.can_use_cards.at(0)); if (a) { const n = a.prompt.call(a, e, s, void 0, t); r = n?.prompt, t.options.prompt = n?.prompt, t.options.thinkPrompt = n?.thinkPrompt } } const n = {}, o = t.can_use_cards ?? [], i = t.card_selector && e.getSelectors(t.card_selector.effectId, t.card_selector.name, e.toData_Context(t.card_selector.context)), c = n?.selectors && Object.keys(n.selectors).find((e => "card" === n.selectors[e].type)), g = c && i[c], u = t.target_selector && e.getSelectors(t.target_selector.effectId, t.target_selector.name, e.toData_Context(t.target_selector.context)), l = n?.selectors && Object.keys(n.selectors).find((e => "card" === n.selectors[e].type)), d = l && u[l]; if (t.skip_card) { const s = { type: "player", step: 9, onChange (s, r) { "init" === s && (this._use_or_play_vcard = e.createVirtualCardByData(t.skip_card, !0, !1), this._carduse_skill = e.getCardUse(t.skip_card), this.selectors.target = a(e, this, t, d)) } }; return void (n.target = s) } const h = g ?? { type: "card" }; return h.step = 1, h.count = h.count ?? 1, h.selectable = h.selectable ?? s.getHandCards(!0), h.filter = function (e, a) { return g ? g.filter.call(this, e, a) : !!o.find((a => { const t = a.split("-")[0]; return e.name === t })) }, h.onChange = function (i, c) { if (!this.selectors.card.complete) return this._use_or_play_vcard = void 0, this._carduse_skill = void 0, this.selectors.target = void 0, void (this.options.prompt = r); if (g && g.onChange?.call(this, i, c), !this._use_or_play_vcard) { const a = c.name, t = o.find((e => e.split("-")[0] === a))?.split("-")[1] ?? 1; this._use_or_play_vcard = e.createVirtualCardByOne(c, !1), this._use_or_play_vcard.custom.method = t } if (!t.skip_target && (this._carduse_skill = e.getCardUse(this._use_or_play_vcard.vdata), this._carduse_skill)) { const r = this._carduse_skill.prompt.call(this._carduse_skill, e, s, this._use_or_play_vcard.vdata, t); r && (this.options.prompt = r?.prompt), this._carduse_skill.target ? this.selectors.target = a(e, this, t, d) : s.canUseCard(this._use_or_play_vcard.vdata, void 0, "", d) && delete n.target } }, n.card = h, { selectors: n, options: t.options ?? {} } }(e, t), play_card: () => function (e, a) { const t = a.from; if (!t) return { selectors: {}, options: {} }; a.options || (a.options = {}); const s = {}, r = a.can_play_cards ?? [], n = a.card_selector && e.getSelectors(a.card_selector.effectId, a.card_selector.name, e.toData_Context(a.card_selector.context)), o = s?.selectors && Object.keys(s.selectors).find((e => "card" === s.selectors[e].type)), i = o && n[o], c = i ?? { type: "card" }; return c.step = 1, c.count = c.count ?? 1, c.selectable = c.selectable ?? t.getHandCards(!0), c.filter = function (e, a) { return i ? i.filter.call(this, e, a) : !!r.find((a => a === e.name)) }, c.onChange = function (a, t) { this.selectors.card.complete ? (i && i.onChange?.call(this, a, t), this._use_or_play_vcard || (this._use_or_play_vcard = e.createVirtualCardByOne(t, !1))) : this._use_or_play_vcard = void 0 }, s.card = c, { selectors: s, options: a.options ?? {} } }(e, t), watch_hand: () => { const a = t.targets.at(0); return { selectors: { card: e.createChooseCard({ step: 1, count: 0, selectable: t.cards, selecte_type: "rows", data_rows: [{ title: "handArea", cards: t.cards }], windowOptions: { title: { text: "watch_hand_title", values: [{ type: "player", value: a?.playerId }] }, timebar: 8, buttons: ["confirm"] } }) }, options: { canCancle: !1, showMainButtons: !1, prompt: "watch_hand", ms: 8 } } }, watch_general: () => { const a = t.targets.at(0), s = t.pos; return { selectors: { general: e.createChooseGeneral({ step: 1, count: 0, selecte_type: "win", selectable: e.getGenerals(t.generals), windowOptions: { title: { text: "watch_general_title" + (a ? 2 : 1), values: [{ type: "player", value: a?.playerId }, { type: "string", value: s }] }, timebar: 8, buttons: ["confirm"] } }) }, options: { canCancle: !1, showMainButtons: !1, prompt: "watch_general", ms: 8 } } }, yesorno: () => ({ selectors: { option: e.createChooseOptions({ step: 1, count: 1, selectable: ["yes", "no"] }) }, options: { canCancle: !1, showMainButtons: !1, prompt: t.prompt ?? "" } }), use_skill: () => e.createCac(t.options), choose_pindian: () => ({}), move_filed: () => { const a = t.pos; return { selectors: { target: e.createChoosePlayer({ step: 1, count: 2, filter (e, t) { if (0 === t.length) return !0; const s = t[0]; let r = !1, n = !1; return a.includes("e") && (0 === s.getEquipCards().length && e.getEquipCards().length > 0 && (r = !0), s.getEquipCards().length > 0 && 0 === e.getEquipCards().length && (r = !0), r || (r = e.getEquipCards().some((e => s.getEquipCards().every((a => e.subtype !== a.subtype)))) || s.getEquipCards().some((a => e.getEquipCards().every((e => a.subtype !== e.subtype)))))), a.includes("j") && (0 === s.judgeCards.length && e.judgeCards.length > 0 && (n = !0), s.judgeCards.length > 0 && 0 === e.judgeCards.length && (n = !0), n || (n = e.judgeCards.some((e => s.judgeCards.every((a => e.name !== a.name)))) || s.judgeCards.some((a => e.judgeCards.every((e => a.name !== e.name)))))), r || n } }) }, options: t.options } }, move_filed_card: () => { const a = t.targets, s = t.pos, r = [], n = []; if (n.push({ title: a.at(0)?.gameName, items: [] }), n.push({ title: a.at(1)?.gameName, items: [] }), s.includes("e")) { const e = a[0]?.getEquipCards()?.filter((e => !a[1]?.getEquipCards()?.find((a => a.subtype === e.subtype)))), t = a[1]?.getEquipCards()?.filter((e => !a[0]?.getEquipCards()?.find((a => a.subtype === e.subtype)))); r.push(...e, ...t), n.forEach(((e, t) => { e.items.push({ title: "武器", card: a.at(t)?.equipCards.find((e => 31 === e.subtype)) }) })), n.forEach(((e, t) => { e.items.push({ title: "防具", card: a.at(t)?.equipCards.find((e => 32 === e.subtype)) }) })), n.forEach(((e, t) => { e.items.push({ title: "特殊坐骑", card: a.at(t)?.equipCards.find((e => 35 === e.subtype)) }) })), n.forEach(((e, t) => { e.items.push({ title: "防御坐骑", card: a.at(t)?.equipCards.find((e => 33 === e.subtype)) }) })), n.forEach(((e, t) => { e.items.push({ title: "进攻坐骑", card: a.at(t)?.equipCards.find((e => 34 === e.subtype)) }) })), n.forEach(((e, t) => { e.items.push({ title: "宝物", card: a.at(t)?.equipCards.find((e => 36 === e.subtype)) }) })) } if (s.includes("j")) { const e = a[0]?.judgeCards?.filter((e => !a[1]?.judgeCards?.find((a => a.name === e.name)))), t = a[1]?.judgeCards?.filter((e => !a[0]?.judgeCards?.find((a => a.name === e.name)))); e.forEach((e => { r.push(...e.subcards) })), t.forEach((e => { r.push(...e.subcards) })), n.forEach(((e, t) => { e.items.push({ title: "乐不思蜀", card: a.at(t)?.judgeCards.find((e => "lebusishu" === e.name))?.subcards[0] }) })), n.forEach(((e, t) => { e.items.push({ title: "兵粮寸断", card: a.at(t)?.judgeCards.find((e => "bingliangcunduan" === e.name))?.subcards[0] }) })), n.forEach(((e, t) => { e.items.push({ title: "闪电", card: a.at(t)?.judgeCards.find((e => "shandian" === e.name))?.subcards[0] }) })) } return { selectors: { card: e.createChooseCard({ step: 1, count: 1, selectable: r, selecte_type: "items", data_items: n, windowOptions: { title: t.options?.prompt, timebar: e.responseTime, prompt: "选择一张牌移动到另一名角色对应的位置", buttons: ["confirm"] } }) }, options: { canCancle: !1, showMainButtons: !1, thinkPrompt: t.options?.prompt } } }, sort_cards: () => { const a = t.cards, s = t.areas, r = [], n = a.slice(); return s.forEach((e => { const a = { title: e.title, items: [] }; for (let t = 0; t < e.max; t++)a.items.push({ title: e.title, card: n.shift() }); r.push(a) })), { selectors: { card: e.createChooseCard({ step: 1, count: 0, selectable: a, selecte_type: "drags", data_items: r, windowOptions: { title: t.options?.prompt, timebar: e.responseTime, prompt: "请拖动卡牌调整顺序", buttons: ["confirm"] } }) }, options: t.options } } }) }); var s, r; sgs.loadTranslation({ "@playphase": "出牌阶段，请选择一张牌", "@@playphase": "出牌阶段", watch_hand_title: "观看{0}的手牌", "@watch_hand": "", "@@watch_hand": "观看手牌", watch_general_title1: "观看武将牌", watch_general_title2: "观看{0}的{1}", "@watch_general": "", "@@watch_general": "观看武将牌" }), sgs.loadTranslation({ confirm: "确定", cancle: "取消", yes: "是", no: "否", shibingn: "士兵", shibingv: "士兵", suit0: "", suit3: "梅花", suit1: "黑桃", suit4: "方片", suit2: "红桃", img_suit3: "♣", img_suit1: "♠", img_suit4: "♦", img_suit2: "♥", color0: "", color1: "红色", color2: "黑色", "@playphase": "出牌阶段，请选择一张牌", "@think:playphase": "出牌阶段", handArea: "手牌区", equipArea: "装备区", judgeArea: "判定区", "@invoke_skill": "请选择一个技能", "@think:invoke_skill": "技能", wei: "魏", shu: "蜀", wu: "吴", qun: "群", jin: "晋", ye: "野心家", top: "顶", bottom: "底", head: "主将", deputy: "副将", head_and_deputy: "主将和副将", all: "全部", phase1: "准备阶段", phase2: "判定阶段", phase3: "摸牌阶段", phase4: "出牌阶段", phase5: "弃牌阶段", phase6: "结束阶段", damage0: "普通", damage1: "火焰", damage2: "雷电", "#playphase_open_head": "明置主将", "#playphase_open_deputy": "明置副将", "#canclePreshow": "取消预亮", "#preshow": "预亮", skill: "技能", equip_skill: "装备技能", general_skill: "武将技能" }), sgs.loadTranslation({ "string:number-1": "", "string:number0": "joker", "string:number1": "A", "string:number2": "2", "string:number3": "3", "string:number4": "4", "string:number5": "5", "string:number6": "6", "string:number7": "7", "string:number8": "8", "string:number9": "9", "string:number10": "10", "string:number11": "J", "string:number12": "Q", "string:number13": "K", "string:number14": "JOKER", "string:area0": "未知区域", "string:area99": "武将牌堆", "string:area1": "牌堆", "string:area2": "弃牌堆", "string:area3": "处理区", "string:area4": "仓廪", "string:area5": "府库", "string:area6": "后备区", "string:area91": "手牌", "string:area92": "装备区", "string:area93": "判定区", "string:area94": "武将牌上", "string:area95": "武将牌旁" }), sgs.loadTranslation({ "#GameStart": "游戏开始", "#TurnStart": "----------------------------\n[b][color=#008000]{0}[/color][/b] 回合开始", "#TurnEnd": "[b][color=#008000]{0}[/color][/b] 回合结束", "#TurnSkip": "[b][color=#008000]{0}[/color][/b] 回合被跳过", "#DamageLog1": "[b][color=#008000]{0}[/color][/b] 对 [b][color=#ff0000]{1}[/color][/b] 造成了[color=#ff0000]{2}[/color]点{3}伤害\n[b][color=#ff0000]{1}[/color][/b] 当前体力值为{4} 体力上限为{5}", "#DamageLog2": "[b][color=#ff0000]{0}[/color][/b] 受到了[color=#ff0000]{1}[/color]点{2}伤害\n[b][color=#ff0000]{0}[/color][/b] 当前体力值为{3} 体力上限为{4}", "#LoseHp": "[b][color=#ff0000]{0}[/color][/b] 失去了[color=#ff0000]{1}[/color]点体力\n[b][color=#ff0000]{0}[/color][/b] 当前体力值为{2} 体力上限为{3}", "#Dying": "[b][color=#ff0000]{0}[/color][/b] 进入濒死状态 需要{1}个桃", "#Death1": "[b][color=#ff0000]{0}[/color][/b] 自杀", "#Death2": "[b][color=#ff0000]{0}[/color][/b] 死亡", "#Death3": "[b][color=#008000]{0}[/color][/b] 杀死了 [b][color=#ff0000]{1}[/color][/b]", "#RecoverHp": "[b][color=#008000]{0}[/color][/b] 回复了[color=#008000]{1}[/color]点体力\n[b][color=#ff0000]{0}[/color][/b] 当前体力值为{2} 体力上限为{3}", "#IncreaseMaxHp": "[b][color=#008000]{0}[/color][/b] 增加了[color=#008000]{1}[/color]点体力体力上限\n[b][color=#ff0000]{0}[/color][/b] 当前体力值为{2} 体力上限为{3}", "#ReduceMaxHp": "[b][color=#ff0000]{0}[/color][/b] 减少了[color=#ff0000]{1}[/color]点体力上限\n[b][color=#ff0000]{0}[/color][/b] 当前体力值为{2} 体力上限为{3}", "#JudgeCard": "[b][color=#008000]{0}[/color][/b] {1}的判定牌为{2}", "#JudgeSuccess": "[b][color=#008000]{0}[/color][/b] {1}的判定结果为{2}\n[b][color=#ff0000]{0}[/color][/b] {1}的判定[b]生效[/b]", "#JudgeLose": "[b][color=#ff0000]{0}[/color][/b] {1}的判定结果为{2}\n[b][color=#ff0000]{0}[/color][/b] {1}的判定[b]失效[/b]", "#Open": "[b][color=#008000]{0}[/color][/b] 明置了{1}：[b][color=#ffff00]{2}[/color][/b]", "#Close": "[b][color=#008000]{0}[/color][/b] 暗置了{1}：[b][color=#ffff00]{2}[/color][/b]", "#Chained1": "[b][color=#008000]{0}[/color][/b] 横置", "#Chained2": "[b][color=#008000]{0}[/color][/b] 重置", "#Skip1": "[b][color=#008000]{0}[/color][/b] 叠置", "#Skip2": "[b][color=#008000]{0}[/color][/b] 平置", "#Skip3": "[b][color=#008000]{0}[/color][/b] 翻至背面", "#Skip4": "[b][color=#008000]{0}[/color][/b] 翻至正面", "#Change": "[b][color=#008000]{0}[/color][/b] 变更了{1}：[b][color=#ffff00]{2}[/color][/b]->[b][color=#ffff00]{3}[/color][/b]", "#Remove": "[b][color=#008000]{0}[/color][/b] 移除了{1}：[b][color=#ffff00]{2}[/color][/b]", "#WatchHand": "[b][color=#008000]{0}[/color][/b] 观看了[b][color=#ff0000]{1}[/color][/b]的手牌{2}", "#WatchGeneral1": "[b][color=#008000]{0}[/color][/b] 观看了[b][color=#ff0000]{1}[/color][/b]的{2} [b][color=#008000]{3}[/color][/b]", "#WatchGeneral2": "[b][color=#008000]{0}[/color][/b] 观看了{1}张武将牌 [b][color=#008000]{2}[/color][/b]", "#ChooseJunling": "[b][color=#008000]{0}[/color][/b] 选择了[b][color=#008000]军令{1}[/color][/b]", "#ChooseJunling_Yes": "[b][color=#ff0000]{0}[/color][/b] 选择执行军令", "#ChooseJunling_No": "[b][color=#ff0000]{0}[/color][/b] 选择不执行军令", "#UseSkill1": "[b][color=#008000]{0}[/color][/b] 使用了{1}[color=#ffff00]{2}[/color] ", "#UseSkill2": "[b][color=#008000]{0}[/color][/b] 使用了{1}[color=#ffff00]{2}[/color] 目标是：[b][color=#ff0000]{1}[/color][/b]" }), sgs.loadTranslation({ "#Move_PutTo": "{0}置于{1}", "#PutToCard": "[b][color=#008000]{0}[/color][/b] 将{1}张牌{2}置于{3}", "#Move_Draw": "{0}<br/>摸牌", "#DrawCard": "[b][color=#008000]{0}[/color][/b] 从牌堆{1}摸了{2}张牌{3}", "#Move_Drop": "{0}弃置", "#DropCard1": "[b][color=#008000]{0}[/color][/b] {1}弃置了{2}张牌{3}", "#DropCard2": "[b][color=#008000]{0}[/color][/b] {1}弃置了[color=#ff0000]{2}[/color][/b]的{3}张牌{4}", "#Move_Obtain": "{0}获得", "#ObtainCard1": "[b][color=#008000]{0}[/color][/b] {1}获得了{2}张牌{3}", "#ObtainCard2": "[b][color=#008000]{0}[/color][/b] {1}获得了[color=#ff0000]{2}[/color][/b]的{3}张牌{4}", "#Move_Recast": "{0}重铸", "#RecastCard": "[b][color=#008000]{0}[/color][/b] {1}重铸了{2}", "#Move_Give": "{0}交给{1}", "#GiveCard": "[b][color=#008000]{0}[/color][/b] {1}交给了[color=#ff0000]{2}[/color][/b]的{3}张牌{4}", "#Move_Flash1": "{0}亮出", "#Move_Flash2": "亮出", "#Move_Show1": "{0}展示", "#Move_Show2": "展示", "#ShowCard": "[b][color=#008000]{0}[/color][/b] {1}展示：{2}", "#Move_Judge": "{0}{1}判定", "#Move_Play": "{0}打出", "#PlayCard": "[b][color=#008000]{0}[/color][/b] 打出卡牌{1}", "#Move_Use": "{0}使用", "#Move_UseSp": "{0}", "#UseCard": "[b][color=#008000]{0}[/color][/b] 使用卡牌{1} 目标是：[b][color=#ff0000]{2}[/color][/b]", "#UseCardSp": "[b][color=#ff0000]{0}[/color][/b] {1}开始判定", "#Install_Equip": "[b][color=#008000]{0}[/color][/b] 装备了[b][color=#ff0000]{1}[/color][/b]", "#UnInstall_Equip": "[b][color=#008000]{0}[/color][/b] 卸下了装备[b][color=#ff0000]{1}[/color][/b]" }), function (e) { e[e.None = 0] = "None", e[e.Trigger = 1] = "Trigger", e[e.State = 2] = "State" }(s || (s = {})), function (e) { e[e.Distance_Correct = 1] = "Distance_Correct", e[e.Distance_Fixed = 2] = "Distance_Fixed", e[e.NotCalcSeat = 3] = "NotCalcSeat", e[e.NotCalcDistance = 4] = "NotCalcDistance", e[e.MaxHand_Initial = 5] = "MaxHand_Initial", e[e.MaxHand_Correct = 6] = "MaxHand_Correct", e[e.MaxHand_Fixed = 7] = "MaxHand_Fixed", e[e.MaxHand_Exclude = 8] = "MaxHand_Exclude", e[e.Prohibit_Open = 9] = "Prohibit_Open", e[e.Prohibit_Close = 10] = "Prohibit_Close", e[e.Prohibit_DropCards = 11] = "Prohibit_DropCards", e[e.Prohibit_RecoverHp = 12] = "Prohibit_RecoverHp", e[e.Prohibit_UseCard = 13] = "Prohibit_UseCard", e[e.Prohibit_PlayCard = 14] = "Prohibit_PlayCard", e[e.Prohibit_Pindian = 15] = "Prohibit_Pindian", e[e.Range_Initial = 16] = "Range_Initial", e[e.Range_Correct = 17] = "Range_Correct", e[e.Range_Fixed = 18] = "Range_Fixed", e[e.Range_Within = 19] = "Range_Within", e[e.Range_Without = 20] = "Range_Without", e[e.Regard_CardData = 21] = "Regard_CardData", e[e.Regard_OnlyBig = 22] = "Regard_OnlyBig", e[e.TargetMod_PassTimeCheck = 23] = "TargetMod_PassTimeCheck", e[e.TargetMod_PassCountingTime = 24] = "TargetMod_PassCountingTime", e[e.TargetMod_CorrectTime = 25] = "TargetMod_CorrectTime", e[e.TargetMod_PassDistanceCheck = 26] = "TargetMod_PassDistanceCheck", e[e.Skill_Invalidity = 27] = "Skill_Invalidity" }(r || (r = {})); const n = sgs.CardUse({ name: "sha", method: 1, trigger: "PlayPhaseProceeding", timeCondition: (e, a, t) => 1, distanceCondition: (e, a, t, s) => a.rangeOf(t), target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (e, t) => a !== e }), async onuse (e, a) { const { from: t, card: s, source: n } = a; if (a.baseDamage = 1 + (t.getMark("jiu_state") ?? 0), t.setMark("jiu_state", 0), n.is(sgs.DataType.PhaseEvent) && "PlayPhaseProceeding" === n.trigger && n.executor === t) { e.getStates(r.TargetMod_PassCountingTime, [t, s.vdata, void 0]).some((e => e)) || t.increaseMark("__sha_times", 1) } }, async effect (e, a, t) { const { card: s, from: r, current: n, baseDamage: o = 1 } = t; let i = 0; s.hasAttr(2) && (i = 2), s.hasAttr(1) && (i = 1), await e.damage({ from: r, to: n.target, number: o, damageType: i, channel: s, isChain: !1, source: t, reason: this.name }) } }); sgs.setCardData("sha", { type: 1, subtype: 1, damage: !0 }), sgs.loadTranslation({ sha: "杀", "@desc:sha": "基本牌\n\n使用时机：出牌阶段限一次。\n使用目标：你的攻击范围内的一名其他角色。\n作用效果：你对目标对应的角色造成1点普通伤害。", "@sha": "选择一名角色，对他造成伤害" }); const o = sgs.CardUse({ name: "shan", method: 1, trigger: "CardEffectBefore", prompt: (e, a, t, s) => s.prompt ? s.prompt : "", condition (e, a, t, s) { if (s.is(sgs.DataType.UseCardEvent) && "sha" === s.card.name && s.current.target === a) return s.card }, async effect (e, a, t) { const { from: s, source: r } = t; r.is(sgs.DataType.UseCardEvent) && "sha" === r.card.name && r.current.target === s && (r.current.offset = t) } }); sgs.setCardData("shan", { type: 1, subtype: 1, rhyme: "an" }), sgs.loadTranslation({ shan: "闪", "@desc:shan": "基本牌\n\n使用时机：当【杀】对对应的角色为你的目标生效前。\n使用目标：此【杀】。\n作用效果：抵消此【杀】。", "@shan": "{0}对你使用【杀】，是否使用【闪】" }); const i = sgs.CardUse({ name: "tao", method: 1, trigger: "PlayPhaseProceeding", target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (e, t) => a === e && e.losshp > 0, auto: !0 }), async onuse (e, a) { a.baseRecover = 1 }, async effect (e, a, t) { const { current: s, baseRecover: r = 1 } = t; await e.recoverhp({ player: s.target, number: r, source: t, reason: this.name }) } }), c = sgs.CardUse({ name: "tao", method: 2, trigger: "Dying", condition: (e, a, t, s) => s.is(sgs.DataType.DyingEvent) && s.player.hp <= 0, prompt: (e, a, t, s) => s.prompt ? s.prompt : {}, target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (a, t) => a.hp <= 0 && Math.max(...e.players.map((e => e.indying))) === a.indying, auto: !0 }), async onuse (e, a) { a.baseRecover = 1 }, async effect (e, a, t) { const { current: s, baseRecover: r = 1 } = t; await e.recoverhp({ player: s.target, number: r, source: t, reason: this.name }) } }); sgs.setCardData("tao", { type: 1, subtype: 1, recover: !0, rhyme: "ao" }), sgs.loadTranslation({ tao: "桃", "@desc:tao": "基本牌\n\n使用时机：出牌阶段/一名角色处于濒死状态时。\n使用目标：已受伤的你/处于濒死状态的角色。\n作用效果：目标对应的角色回复1点体力。", "@tao": "点击确定，回复1点体力", "@dying": "{0}处于濒死状态，需要{1}个桃", "@@dying": "濒死" }); const g = sgs.CardUse({ name: "jiu", method: 1, trigger: "PlayPhaseProceeding", timeCondition: (e, a, t) => 1, target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (e, t) => a === e, auto: !0 }), async onuse (e, a) { const { from: t, card: s, source: n } = a; e.getStates(r.TargetMod_PassCountingTime, [t, s.vdata, void 0]).some((e => e)) || t.increaseMark("__jiu_times", 1) }, async effect (e, a, t) { const { current: s } = t; s.target.increaseMark("jiu_state") } }), u = sgs.CardUse({ name: "jiu", method: 2, trigger: "Dying", condition: (e, a, t, s) => s.is(sgs.DataType.DyingEvent) && s.player === a && s.player.hp <= 0, prompt: (e, a, t, s) => s.prompt ? s.prompt : {}, target (e, a, t) { const s = Math.max(...e.players.map((e => e.indying))), r = e.players.find((e => e.indying === s)); return e.createChoosePlayer({ count: 1, filter: (e, t) => a === e && e === r && e.hp <= 0, auto: !0 }) }, async onuse (e, a) { a.baseRecover = 1 }, async effect (e, a, t) { const { current: s, baseRecover: r = 1 } = t; await e.recoverhp({ player: s.target, number: r, source: t, reason: this.name }) } }); sgs.setCardData("jiu", { type: 1, subtype: 1, recover: !0, rhyme: "iu" }), sgs.loadTranslation({ jiu: "酒", "@desc:jiu": "基本牌\n\n使用时机：出牌阶段/你处于濒死状态时。\n使用目标：你。\n作用效果：目标对应的角色于此回合内使用的下一张【杀】的伤害值基数+1/目标对应的角色回复1点体力。", "@jiu": "点击确定，本回合下一张【杀】伤害+1" }); const l = sgs.CardUse({ name: "wuzhongshengyou", method: 1, trigger: "PlayPhaseProceeding", target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (e, t) => a === e, auto: !0 }), async effect (e, a, t) { const { current: s } = t; await e.drawCards({ player: s.target, count: 2, source: t, reason: this.name }) } }); sgs.setCardData("wuzhongshengyou", { type: 2, subtype: 21, length: 4, rhyme: "ou" }), sgs.loadTranslation({ wuzhongshengyou: "无中生有", "@desc:wuzhongshengyou": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：你。\n作用效果：目标对应的角色摸两张牌。", "@wuzhongshengyou": "点击确定，摸两张牌" }); const d = sgs.CardUse({ name: "bingliangcunduan", method: 1, trigger: "PlayPhaseProceeding", target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (e, t) => a !== e && !e.hasJudgeCard("bingliangcunduan") }), distanceCondition: (e, a, t, s) => 1 === a.distanceTo(t), async effect (e, a, t) { (await e.judge({ player: a.target, isSucc: e => 3 !== e.suit, source: t, reason: this.name })).success && await e.currentTurn.skipPhase(3) } }); sgs.setCardData("bingliangcunduan", { type: 2, subtype: 22, length: 4, rhyme: "an" }), sgs.loadTranslation({ bingliangcunduan: "兵粮寸断", "@desc:bingliangcunduan": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：距离为1的一名其他角色。\n作用效果：目标对应的角色判定。若结果不为梅花，其跳过摸牌阶段。", "@bingliangcunduan": "选择一名角色，他判定，如果不是梅花跳过摸牌阶段" }); const h = sgs.TriggerEffect({ name: "guohechaiqiao_choose", getSelectors (e, a) { const t = a.from, s = a.targets.at(0); return { choose: () => ({ selectors: { cards: e.createDropCards(t, { step: 1, count: 1, selecte_type: "rows", selectable: s.getAreaCards(), data_rows: s.getCardsToArea("hej"), windowOptions: { title: "过河拆桥", timebar: e.responseTime, prompt: "过河拆桥，请选择一张牌" } }) }, options: { canCancle: !1, showMainButtons: !1, prompt: "", thinkPrompt: "过河拆桥" } }) } } }), p = sgs.CardUse({ name: "guohechaiqiao", method: 1, trigger: "PlayPhaseProceeding", effects: [h.name], target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (e, t) => a !== e && e.hasCardsInArea(!0) }), async effect (e, a, t) { const { from: s, current: r } = t, n = e.getData("guohechaiqiao_choose"), o = (await e.doRequest({ player: s, get_selectors: { effectId: n.id, name: "choose", context: { from: s, targets: [r.target] } } })).result.results.cards.result; await e.dropCards({ player: s, cards: o, source: t, reason: this.name }) } }); sgs.setCardData("guohechaiqiao", { type: 2, subtype: 21, length: 4, rhyme: "ao" }), sgs.loadTranslation({ guohechaiqiao: "过河拆桥", "@desc:guohechaiqiao": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：一名区域内有牌的其他角色。\n作用效果：你弃置目标对应的角色区域里的一张牌。", "@guohechaiqiao": "选择一名角色，弃置他区域里的一张牌" }); const f = sgs.TriggerEffect({ name: "huogong_choose", getSelectors (e, a) { const t = a.targets.at(0); return { show: () => ({ selectors: { card: e.createChooseCard({ step: 1, count: 1, selectable: t.getHandCards() }) }, options: { canCancle: !1, showMainButtons: !0, prompt: "火攻，请展示一张手牌", thinkPrompt: "火攻展示牌" } }), drop: () => { const s = a.from, r = a.suit, n = sgs.getTranslation(`suit${r}`); return { selectors: { card: e.createDropCards(s, { step: 1, count: 1, selectable: s.getHandCards(), filter: (e, a) => e.suit === r }) }, options: { canCancle: !0, showMainButtons: !0, prompt: `火攻，你可以弃置一张${n}牌，对${t.gameName}造成1点火焰伤害`, thinkPrompt: "火攻弃置牌" } } } } } }), m = sgs.CardUse({ name: "huogong", method: 1, trigger: "PlayPhaseProceeding", effects: [f.name], target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (e, a) => e.hasHandCards() }), async onuse (e, a) { a.baseDamage = 1 }, async effect (e, a, t) { const { from: s, card: r, current: n, baseDamage: o = 1 } = t, i = e.getData("huogong_choose"), c = await e.doRequest({ player: n.target, get_selectors: { effectId: i.id, name: "show", context: { targets: [n.target] } } }), g = e.getResult(c, "card").result.at(0); if (!g) return; if (!await e.showCards({ player: n.target, cards: [g], source: t, reason: this.name })) return; const u = await e.doRequest({ player: s, get_selectors: { effectId: i.id, name: "drop", context: { suit: g.suit, from: s, targets: [n.target] } } }), l = e.getResult(u, "card").result.at(0); l && (await e.dropCards({ player: s, cards: [l], source: t, reason: this.name }), await e.damage({ from: s, to: n.target, number: o, damageType: 1, channel: r, isChain: !1, source: t, reason: this.name })) } }); sgs.setCardData("huogong", { type: 2, subtype: 21, length: 2, damage: !0, rhyme: "ong" }), sgs.loadTranslation({ huogong: "火攻", "@desc:huogong": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：一名有手牌的角色。\n作用效果：目标对应的角色展示一张手牌。你可弃置与此牌花色相同的一张手牌▷其受到你造成的1点火焰伤害。", "@huogong": "选择一名角色为目标，他展示一张手牌，你可以弃置同花色的手牌对他造成伤害" }); const y = sgs.TriggerEffect({ name: "jiedaosharen_choose", getSelectors (e, a) { const t = a.targets; return { target: () => ({ selectors: { target: e.createChoosePlayer({ filter: (e, a) => 0 !== a.length || t.includes(e) }) } }) } } }), _ = sgs.CardUse({ name: "jiedaosharen", method: 1, trigger: "PlayPhaseProceeding", effects: [y.name], target (e, a, t) { const s = e.createVirtualCardByNone("sha", void 0, !1); s.custom.method = 1, s.custom.skipTimes = !0; const r = s.vdata; return e.createChoosePlayer({ count: 2, filter: (e, t) => 0 === t.length ? a !== e && !!e.getEquip(31) : 1 === t.length && t[0].canUseCard(r, [e], "jiedaosharen", void 0) }) }, async onuse (e, a) { const { from: t } = a, s = a.targets.slice(); a.targets.length = 0; for (let r = 0; ; r += 2) { const n = s.slice(r, 2); if (n.length < 2) break; a.addTarget(n[0]).subTargets = [n[1]], e.directLine(t, n, 3) } }, async effect (e, a, t) { const { from: s, card: r, current: n, baseDamage: o = 1, cantResponse: i } = t, c = e.getData("jiedaosharen_choose"), g = ["sha.1"]; i.includes(n.target) && (g.length = 0); const u = await e.needUseCard({ from: n.target, cards: g, targetSelector: { effectId: c.id, name: "target", context: { targets: n.subTargets } }, source: t, reason: this.name, reqOptions: { canCancle: !0, prompt: { text: "jiedaosharen_response", values: [{ type: "player", value: n.subTargets.at(0)?.playerId }, { type: "player", value: s.playerId }] } } }), l = n.target.getEquip(31); !u && l && await e.giveCards({ from: n.target, to: s, cards: [l], source: t, reason: this.name }) } }); sgs.setCardData("jiedaosharen", { type: 2, subtype: 21, length: 4, rhyme: "en" }), sgs.loadTranslation({ jiedaosharen: "借刀杀人", "@desc:jiedaosharen": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：一名装备区里有武器牌且攻击范围内有其使用【杀】的合法目标的其他角色An。\n执行动作：你在选择对应的角色为An的目标的同时选择An攻击范围内的是An使用【杀】的合法目标的一名角色Bn；你在An也成为此【借刀杀人】的目标的同时选择An攻击范围内的是An使用【杀】的合法目标的一名角色Bn。\n目标对应的角色An需对包括Bn在内的角色使用【杀】，否则将装备区里的武器牌交给你。（n为目标对应的角色的序号）", "@jiedaosharen": "选择一名有武器的角色为目标，他需要使用【杀】，否则将武器交给你", "@jiedaosharen_response": "借刀杀人：你需要对包含{0}在内的角色使用【杀】。否则将武器牌交给{1}", "@@jiedaosharen_response": "借刀杀人" }); const b = sgs.CardUse({ name: "juedou", method: 1, trigger: "PlayPhaseProceeding", target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (e, t) => a !== e }), async onuse (e, a) { a.baseDamage = 1 }, async effect (e, a, t) { const { from: s, card: r, current: n, baseDamage: o = 1 } = t, i = []; for (i.push(n.target), n.wushuang.includes(s) && i.push(n.target), i.push(s), n.wushuang.includes(n.target) && i.push(s); ;) { const a = i.shift(); i.push(a); const c = a === s ? n.target : s, g = ["sha"]; let u; if (t.cantResponse.includes(a) || (u = await e.needPlayCard({ from: a, cards: g, source: t, reason: this.name, reqOptions: { canCancle: !0, showMainButtons: !0, prompt: "@juedou_response", thinkPrompt: "@@juedou_response" } })), !u) { await e.damage({ from: c, to: a, number: o, damageType: 0, channel: r, isChain: !1, source: t, reason: this.name }); break } } } }); sgs.setCardData("juedou", { type: 2, subtype: 21, length: 2, damage: !0, rhyme: "ou" }), sgs.loadTranslation({ juedou: "决斗", "@desc:juedou": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：一名其他角色。\n作用效果：由目标对应的角色开始，其与你轮流打出【杀】，直到其与你中的一名角色未打出【杀】。未打出【杀】的角色受到其与你中的另一名角色造成的1点普通伤害。", "@juedou": "选择一名角色为目标，你与他轮流打出【杀】，没打出【杀】的角色受到对方的伤害", "@juedou_response": "决斗：你需要打出一张【杀】，否则受到1点伤害", "@@juedou_response": "决斗" }); const C = sgs.CardUse({ name: "lebusishu", method: 1, trigger: "PlayPhaseProceeding", target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (e, t) => a !== e && !e.hasJudgeCard("lebusishu") }), async effect (e, a, t) { (await e.judge({ player: a.target, isSucc: e => 2 !== e.suit, source: t, reason: this.name })).success && await e.currentTurn.skipPhase(4) } }); sgs.setCardData("lebusishu", { type: 2, subtype: 22, length: 4, rhyme: "u" }), sgs.loadTranslation({ lebusishu: "乐不思蜀", "@desc:lebusishu": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：距离为1的一名其他角色。\n作用效果：目标对应的角色判定。若结果不为红桃，其跳过出牌阶段。", "@lebusishu": "选择一名角色，他判定，如果不是红桃跳过出牌阶段" }); const w = sgs.CardUse({ name: "nanmanruqin", method: 1, trigger: "PlayPhaseProceeding", target: (e, a, t) => e.createChoosePlayer({ count: [1, -1], filter: (e, t) => a !== e, auto: !0 }), async onuse (e, a) { a.baseDamage = 1 }, async effect (e, a, t) { const { from: s, card: r, current: n, baseDamage: o = 1 } = t, i = ["sha"]; let c; t.cantResponse.includes(n.target) || (c = await e.needPlayCard({ from: n.target, cards: i, source: t, reason: this.name, reqOptions: { canCancle: !0, showMainButtons: !0, prompt: "@nanmanruqin_response", thinkPrompt: "@@nanmanruqin_response" } })), c || await e.damage({ from: s, to: n.target, number: o, damageType: 0, channel: r, isChain: !1, source: t, reason: this.name }) } }); sgs.setCardData("nanmanruqin", { type: 2, subtype: 21, length: 4, damage: !0, rhyme: "in" }), sgs.loadTranslation({ nanmanruqin: "南蛮入侵", "@desc:nanmanruqin": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：所有其他角色。\n作用效果：目标对应的角色需打出【杀】，否则受到你造成的1点普通伤害。", "@nanmanruqin": "所有人依次打出【杀】，没打出【杀】的角色受到伤害", "@nanmanruqin_response": "南蛮入侵：你需要打出一张【杀】，否则受到1点伤害", "@@nanmanruqin_response": "南蛮入侵" }); const T = sgs.TriggerEffect({ name: "shandian_end", priorityType: 5, trigger: "UseCardEnd1", can_trigger: (e, a, t) => t.is(sgs.DataType.UseCardSpecialEvent) && "shandian" === t.card.name && !t.data.damaged, async cost (e, a, t) { let s = a.target.target.next; for (; s;) { const t = e.createEventData(sgs.DataType.PutToCardsData, { player: s, cards: a.card.subcards, toArea: s.judgeArea, movetype: 1, puttype: 1, animation: !1, source: a, reason: this.name }); if (t.check()) { await e.puto(t); break } if (s = s.next, s === a.target.target.next) break } return !0 } }), E = sgs.CardUse({ name: "shandian", method: 1, trigger: "PlayPhaseProceeding", effects: [T.name], target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (e, t) => a === e && !e.hasJudgeCard("shandian"), auto: !0 }), async effect (e, a, t) { (await e.judge({ player: a.target, isSucc: e => 1 === e.suit && e.number >= 2 && e.number <= 9, source: t, reason: this.name })).success && (t.data.damaged = !0, await e.damage({ to: a.target, number: 3, damageType: 2, channel: t.card, isChain: !1, source: t, reason: this.name })) } }); sgs.setCardData("shandian", { type: 2, subtype: 22, length: 2, damage: !0, rhyme: "an" }), sgs.loadTranslation({ shandian: "闪电", "@desc:shandian": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：你。\n作用效果：目标对应的角色判定。若结果为黑桃2~9，其受到3点无来源的雷电伤害。", "@shandian": "所有人轮流判定，结果是黑桃2-9受到3点雷电伤害" }); const D = sgs.TriggerEffect({ name: "shunshouqianyang_choose", getSelectors (e, a) { const t = a.targets.at(0); return { choose: () => ({ selectors: { cards: e.createChooseCard({ step: 1, count: 1, selecte_type: "rows", selectable: t.getAreaCards(), data_rows: t.getCardsToArea("hej"), windowOptions: { title: "顺手牵羊", timebar: e.responseTime, prompt: "顺手牵羊，请选择一张牌" } }) }, options: { canCancle: !1, showMainButtons: !1, prompt: "", thinkPrompt: "顺手牵羊" } }) } } }), q = sgs.CardUse({ name: "shunshouqianyang", method: 1, trigger: "PlayPhaseProceeding", effects: [D.name], distanceCondition: (e, a, t, s) => 1 === a.distanceTo(t), target: (e, a, t) => e.createChoosePlayer({ count: 1, filter: (e, t) => a !== e && e.hasCardsInArea(!0) }), async effect (e, a, t) { const { from: s, current: r } = t, n = e.getData("shunshouqianyang_choose"), o = (await e.doRequest({ player: s, get_selectors: { effectId: n.id, name: "choose", context: { from: s, targets: [r.target] } } })).result.results.cards.result; await e.obtainCards({ player: s, cards: o, source: t, reason: this.name }) } }); sgs.setCardData("shunshouqianyang", { type: 2, subtype: 21, length: 4, rhyme: "ang" }), sgs.loadTranslation({ shunshouqianyang: "顺手牵羊", "@desc:wuzhongshengyou": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：距离为1的一名区域里有牌的其他角色。\n作用效果：你获得目标对应的角色的区域里的一张牌。", "@shunshouqianyang": "选择一名角色，获得他区域里的一张牌" }); const v = sgs.TriggerEffect({ name: "taoyuanjieyi_invalid", priorityType: 3, trigger: "CardEffectStart", can_trigger: (e, a, t) => t.is(sgs.DataType.UseCardEvent) && t.current.target === a && "taoyuanjieyi" === t.card.name && 0 === a.losshp, cost: async (e, a, t) => (a.current.invalid = !0, !0) }), j = sgs.CardUse({ name: "taoyuanjieyi", method: 1, trigger: "PlayPhaseProceeding", effects: [v.name], target: (e, a, t) => e.createChoosePlayer({ count: [1, -1], filter: (e, a) => !0, auto: !0 }), async onuse (e, a) { a.baseRecover = 1 }, async effect (e, a, t) { const { current: s, baseRecover: r = 1 } = t; await e.recoverhp({ player: s.target, number: r, source: t, reason: self.name }) } }); sgs.setCardData("taoyuanjieyi", { type: 2, subtype: 21, length: 4, rhyme: "i" }), sgs.loadTranslation({ taoyuanjieyi: "桃园结义", "@desc:taoyuanjieyi": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：所有角色。\n作用效果：目标对应的角色回复一点体力。", "@taoyuanjieyi": "所有人回复1点体力" }); const k = sgs.CardUse({ name: "tiesuolianhuan", method: 1, trigger: "PlayPhaseProceeding", target: (e, a, t) => e.createChoosePlayer({ count: [1, 2], filter: (e, a) => !0 }), async effect (e, a, t) { const { current: s } = t; await e.chain({ player: s.target, source: t, reason: this.name }) } }); sgs.setCardData("tiesuolianhuan", { type: 2, subtype: 21, length: 4, rhyme: "an" }), sgs.loadTranslation({ tiesuolianhuan: "铁索连环", "@desc:tiesuolianhuan": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：一或两名角色。\n作用效果：目标对应的角色选择：1.横置；2.重置。", "@tiesuolianhuan": "选择一至两名角色，他们进入连环状态或者解除连环状态" }); const P = sgs.CardUse({ name: "wanjianqifa", method: 1, trigger: "PlayPhaseProceeding", target: (e, a, t) => e.createChoosePlayer({ count: [1, -1], filter: (e, t) => a !== e, auto: !0 }), async onuse (e, a) { a.baseDamage = 1 }, async effect (e, a, t) { const { from: s, card: r, current: n, baseDamage: o = 1 } = t, i = ["shan"]; let c; t.cantResponse.includes(n.target) || (c = await e.needPlayCard({ from: n.target, cards: i, source: t, reason: this.name, reqOptions: { canCancle: !0, showMainButtons: !0, prompt: "@wanjianqifa_response", thinkPrompt: "@@wanjianqifa_response" } })), c || await e.damage({ from: s, to: n.target, number: o, damageType: 0, channel: r, isChain: !1, source: t, reason: this.name }) } }); sgs.setCardData("wanjianqifa", { type: 2, subtype: 21, length: 4, damage: !0, rhyme: "a" }), sgs.loadTranslation({ wanjianqifa: "万箭齐发", "@desc:wanjianqifa": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：所有其他角色。\n作用效果：目标对应的角色需打出【闪】，否则受到你造成的1点普通伤害。", "@wanjianqifa": "所有人依次打出【闪】，没打出【闪】的角色受到伤害", "@wanjianqifa_response": "万箭齐发：你需要打出一张【闪】，否则受到1点伤害", "@@wanjianqifa_response": "万箭齐发" }); const z = sgs.TriggerEffect({ name: "wugufengdeng_action1", priorityType: 3, trigger: "UseCardReady", getSelectors: (e, a) => ({ choose: () => ({ selectors: { card: e.createChooseCard({ step: 1, count: 1, selectable: a.cards, selecte_type: "win", windowOptions: { id: a.windowId } }) }, options: { canCancle: !1, showMainButtons: !1, prompt: "wugufengdeng_choose" } }) }), can_trigger: (e, a, t) => t.is(sgs.DataType.UseCardEvent) && t.from === a && "wugufengdeng" === t.card.name, async cost (e, a, t) { const { from: s } = a, r = await e.getNCards(e.aliveCount); await e.puto({ player: s, cards: r, toArea: e.processingArea, puttype: 1, animation: !1, source: a, reason: this.name }), a.data.wugu_cards = r, a.data.wugu_cards_slice = r.slice(); const n = e.window({ create: !0, data: { type: "datas", cards: e.getCardIds(r) }, options: { title: "wugufengdeng" } }); return a.data.wugu_windowId = n, !0 } }), x = sgs.TriggerEffect({ name: "wugufengdeng_action2", priorityType: 3, trigger: "UseCardEnd1", can_trigger: (e, a, t) => t.is(sgs.DataType.UseCardEvent) && t.from === a && "wugufengdeng" === t.card.name, async cost (e, a, t) { const { from: s } = a; return e.window({ close: !0, options: { id: a.data.wugu_windowId } }), !0 } }), S = sgs.CardUse({ name: "wugufengdeng", method: 1, trigger: "PlayPhaseProceeding", effects: [z.name, x.name], target: (e, a, t) => e.createChoosePlayer({ count: [1, -1], filter: (e, a) => !0, auto: !0 }), async effect (e, a, t) { const { current: s, baseRecover: r = 1 } = t, n = t.data.wugu_windowId, o = e.getData("wugufengdeng_action1"); e.window({ options: { id: n, title: this.name, timebar: e.responseTime, prompt: { text: "wugufengdeng_prompt", values: [{ type: "player", value: s.target.playerId }] } } }); const i = await e.doRequest({ player: s.target, get_selectors: { effectId: o.id, name: "choose", context: { windowId: n, cards: t.data.wugu_cards } } }), c = e.getResult(i, "card").result.at(0); c && (c.setLabel({ text: "wugufengdeng_tip", values: [{ type: "player", value: s.target.playerId }] }), await e.obtainCards({ player: s.target, cards: [c], source: t, reason: this.name }), lodash.remove(t.data.wugu_cards, c)) } }); sgs.setCardData("wugufengdeng", { type: 2, subtype: 21, length: 4, rhyme: "eng" }), sgs.loadTranslation({ wugufengdeng: "五谷丰登", "@desc:wugufengdeng": "锦囊牌·普通锦囊牌\n\n使用时机：出牌阶段。\n使用目标：所有角色。\n执行动作：1.当此牌的使用结算准备工作结束时，系统亮出牌堆顶的X张牌（X为此牌的目标对应的角色数）。2.当此牌的使用结算结束后❶，你将处理区里的以此法亮出的牌置入弃牌堆。\n作用效果：目标对应的角色获得这些牌中的一张。", "@wugufengdeng": "所有人依次选择并获得一张牌", wugufengdeng_prompt: "等待{0}选择牌", "@wugufengdeng_choose": "", "@@wugufengdeng_choose": "五谷丰登", wugufengdeng_tip: "{0}" }); const U = sgs.CardUse({ name: "wuxiekeji", method: 1, trigger: "CardEffectBefore", sameTime: !0, prompt: (e, a, t, s) => s.prompt ? s.prompt : "", condition (e, a, t, s) { if (s.is(sgs.DataType.UseCardEvent) && 2 === s.card.type || s.is(sgs.DataType.UseCardSpecialEvent) && 2 === s.card.type || s.is(sgs.DataType.UseCardToCardEvent) && "wuxiekeji" === s.card.name) return s.card }, async effect (e, a, t) { const { from: s, card: r, source: n } = t; if (n.is(sgs.DataType.UseCardEvent) && (n.current.offset = t), n.is(sgs.DataType.UseCardToCardEvent) && (n.target.offset = t), n.is(sgs.DataType.UseCardSpecialEvent) && (n.target.offset = t), r.hasAttr(3) && n.is(sgs.DataType.UseCardEvent)) { const a = n.current.target, r = e.getPlayerByFilter((t => e.sameAsKingdom(a, t))).filter((e => n.targetList.find((a => a.target === e && !a.offset)))); if (r.length > 0) { await e.chooseYesOrNo(s, { prompt: { text: "@wuxiekeji_guo", values: [{ type: "string", value: a.kingdom }] }, thinkPrompt: "@@wuxiekeji_guo" }) && r.forEach((e => { n.targetList.forEach((a => { a.target === e && (a.offset = t) })) })) } } } }); sgs.setCardData("wuxiekeji", { type: 2, subtype: 21, rhyme: "i" }), sgs.loadTranslation({ wuxiekeji: "无懈可击", "@desc:wuxiekeji": "锦囊牌·普通锦囊牌\n\n使用时机：当锦囊牌对目标生效前。\n使用目标：此牌。\n作用效果：抵消此牌。", "@wuxiekeji_response1": "{0}的{1}即将对{2}生效，是否使用【无懈可击】", "@wuxiekeji_response2": "{0}的【无懈可击】即将生效，是否使用【无懈可击】", "@wuxiekeji_response3": "{0}的{1}即将生效，是否使用【无懈可击】", "@wuxiekeji_guo": "国【无懈可击】：是否对所有{0}势力角色生效", "@@wuxiekeji_guo": "国无懈" }); const M = sgs.CardUseEquip({ name: "baguazhen" }); sgs.setCardData("baguazhen", { type: 3, subtype: 32, rhyme: "en" }); const O = sgs.Skill({ name: "baguazhen", attached_equip: "baguazhen" }); O.addEffect(sgs.TriggerEffect({ anim: "baguazhen_skill", audio: ["baguazhen"], priorityType: 2, trigger: "NeedUseCardSpecial", auto_log: 1, forced: "cost", can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.NeedUseCardData)) return t.from === a && t.has("shan") }, async cost (e, a, t) { const { from: s } = t; return await e.judge({ player: s, isSucc: e => 1 === e.color, source: a, reason: this.name }) }, async effect (e, a, t) { const { from: s } = t; if (t.cost.success) { const t = e.createVirtualCardByNone("shan"); t.custom.method = 1, a.used = await e.preUseCard(Object.assign({ from: s, card: t }, a.copy())) } } })), O.addEffect(sgs.TriggerEffect({ anim: "baguazhen_skill", audio: ["baguazhen"], auto_log: 1, priorityType: 2, trigger: "NeedPlayCardSpecial", forced: "cost", can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.NeedPlayCardData)) return t.from === a && t.has("shan") }, async cost (e, a, t) { const { from: s } = t; return await e.judge({ player: s, isSucc: e => 1 === e.color, source: a, reason: this.name }) }, async effect (e, a, t) { const { from: s } = t; if (t.cost.success) { const t = e.createVirtualCardByNone("shan"); a.played = await e.prePlayCard(Object.assign({ from: s, card: t }, a.copy())) } } })), sgs.loadTranslation({ baguazhen: "八卦阵", "@desc:baguazhen": "装备牌·防具牌\n\n当你需要使用/打出【闪】时❶，你可判定▶若结果为红色，你使用/打出无对应的实体牌的【闪】。", "@baguazhen": "装备八卦阵，需要出【闪】时可以判定，红色视为出【闪】" }); const R = sgs.CardUseEquip({ name: "baiyinshizi" }); sgs.setCardData("baiyinshizi", { type: 3, subtype: 32, rhyme: "i" }); const I = sgs.Skill({ name: "baiyinshizi", tag: [1], attached_equip: "baiyinshizi" }); I.addEffect(sgs.TriggerEffect({ anim: "baiyinshizi_skill", audio: ["baiyinshizi"], auto_log: 1, priorityType: 2, trigger: "InflictDamage3", can_trigger (e, a, t) { return this.isOwner(a) && t.is(sgs.DataType.DamageEvent) && t.to === a && t.number > 1 }, cost: async (e, a, t) => (a.number = 1, !0) })), I.addEffect(sgs.TriggerEffect({ priorityType: 2, trigger: "MoveCardBefore2", auto_log: 1, can_trigger (e, a, t) { return this.isOwner(a) && a.losshp > 0 && t.is(sgs.DataType.MoveCardEvent) && t.get(this.skill.sourceEquip)?.fromArea === a.equipArea }, async cost (e, a, t) { const { from: s } = t; return (await e.addEffect("baiyin_effect_delay", s)).setData("baiyin_move", a), !0 } })); const B = sgs.TriggerEffect({ name: "baiyin_effect_delay", anim: "baiyinshizi_skill", audio: ["baiyinshizi"], priorityType: 2, trigger: "MoveCardAfter2", can_trigger (e, a, t) { return this.isOwner(a) && this.getData("baiyin_move") === t }, async cost (e, a, t) { const { from: s } = t; return await this.removeSelf(), await e.recoverhp({ player: s, number: 1, source: a, reason: this.name }) }, lifecycle: [{ trigger: "MoveCardEnd", priority: "after", async on_exec (e, a) { this.getData("baiyin_move") === a && await this.removeSelf() } }] }); sgs.loadTranslation({ baiyinshizi: "白银狮子", "@desc:baiyinshizi": "装备牌·防具牌\n\n①锁定技，当你受到伤害时❸，若伤害值大于1，你将伤害值改为1。\n②锁定技，当你失去装备区里的【白银狮子】前❷，你获得1枚“憩”▶（→）当你失去装备区里的此牌后❷，你回复1点体力。", "@baiyinshizi": "装备白银狮子，最多受到1点伤害，失去时回复1点体力" }); const A = sgs.CardUseEquip({ name: "cixiongshuanggujian" }); sgs.setCardData("cixiongshuanggujian", { type: 3, subtype: 31, rhyme: "an" }); const H = sgs.Skill({ name: "cixiongshuanggujian", attached_equip: "cixiongshuanggujian" }); H.addEffect(sgs.StateEffect({ [r.Range_Initial] (e) { if (this.isOwner(e)) return 2 } })), H.addEffect(sgs.TriggerEffect({ anim: "cixiongshuanggujian_skill", audio: ["cixiongshuanggujian"], auto_log: 1, auto_directline: 1, forced: "cost", priorityType: 2, trigger: "AssignTargeted", getSelectors (e, a) { const t = a.targets.at(0); return { choose: () => ({ selectors: { card: e.createDropCards(t, { step: 1, count: 1, selectable: t.getHandCards() }) }, options: { canCancle: !0, showMainButtons: !0, prompt: `雌雄双股剑：你需要弃置一张牌，否则${a.from?.gameName}摸一张牌`, thinkPrompt: this.skill?.name } }) } }, can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.UseCardEvent)) { const { from: s, current: r, card: n } = t; return "sha" === n.name && a === s && e.differentAsGender(a, r.target) } }, context: (e, a, t) => ({ targets: [t.current.target] }), async cost (e, a, t) { const { from: s, targets: r } = t, n = r.at(0); if (!n) return; const o = await e.doRequest({ player: n, get_selectors: { effectId: this.id, name: "choose", context: t } }), i = e.getResult(o, "card").result; return await e.dropCards({ player: n, cards: i, source: a, reason: this.name }) || await e.drawCards({ player: s, count: 1, source: a, reason: this.name }), !0 } })), sgs.loadTranslation({ cixiongshuanggujian: "雌雄双股剑", "@desc:cixiongshuanggujian": "装备牌·武器牌\n\n攻击范围：2\n当【杀】指定目标后，若使用者为你且此目标对应的角色与你性别不同，你可令其选择：1.弃置一张手牌；2.令你摸一张牌。", "@cixiongshuanggujian": "装备雌雄双股剑，杀异性角色时可以让他选择弃牌或让你摸牌" }); const N = sgs.CardUseEquip({ name: "guanshifu" }); sgs.setCardData("guanshifu", { type: 3, subtype: 31, rhyme: "u" }); const J = sgs.Skill({ name: "guanshifu", attached_equip: "guanshifu" }); J.addEffect(sgs.StateEffect({ [r.Range_Initial] (e) { if (this.isOwner(e)) return 3 } })), J.addEffect(sgs.TriggerEffect({ anim: "guanshifu_skill", audio: ["guanshifu"], auto_log: 1, auto_directline: 1, priorityType: 2, trigger: "BeOffset", getSelectors (e, a) { return { skill_cost: () => { const t = a.from, s = a.targets.at(0); return { selectors: { card: e.createDropCards(t, { step: 1, count: 2, selectable: t.getSelfCards(), filter: (e, a) => "guanshifu" !== e.name }) }, options: { canCancle: !0, showMainButtons: !0, prompt: `贯石斧：你可以弃置两张牌让【杀】依然对${s.gameName}造成伤害`, thinkPrompt: this.skill?.name } } } } }, can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.UseCardEvent)) { const { from: e, current: s, card: r } = t; return "sha" === r.name && a === e && s.target.alive } }, context: (e, a, t) => ({ targets: [t.current.target] }), async cost (e, a, t) { const { from: s, cards: r } = t; return await e.dropCards({ player: s, cards: r, source: a, reason: this.name }) }, async effect (e, a, t) { a.insert(["CardEffect", "CardEffected"]) } })), sgs.loadTranslation({ guanshifu: "贯石斧", "@desc:guanshifu": "装备牌·武器牌\n\n攻击范围：3\n当你使用的【杀】被其中的一个目标对应的角色使用的【闪】抵消后，若其存活，你可弃置两张牌▶不会因此【闪】的抵消而不会生成“此【杀】对此目标生效时”和“此【杀】对此目标生效后”这两个时机。", "@guanshifu": "装备贯石斧，杀被抵消后可以弃置两张牌依然造成伤害" }); const G = sgs.CardUseEquip({ name: "hanbingjian" }); sgs.setCardData("hanbingjian", { type: 3, subtype: 31, rhyme: "an" }); const V = sgs.Skill({ name: "hanbingjian", attached_equip: "hanbingjian" }); function F (e, a) { if (this.isOwner(a)) return 1 } function L (e, a) { if (this.isOwner(e)) return -1 } V.addEffect(sgs.StateEffect({ [r.Range_Initial] (e) { if (this.isOwner(e)) return 2 } })), V.addEffect(sgs.TriggerEffect({ anim: "hanbingjian_skill", audio: ["hanbingjian"], auto_log: 1, auto_directline: 1, forced: "cost", priorityType: 2, trigger: "CauseDamage2", getSelectors (e, a) { return { choose: () => { const t = a.from, s = a.targets.at(0); return { selectors: { cards: e.createDropCards(t, { step: 1, count: 1, selecte_type: "rows", selectable: s.getAreaCards(), data_rows: s.getCardsToArea("he"), windowOptions: { title: this.skill.name, timebar: e.responseTime, prompt: `寒冰剑：请选择一张牌（还剩${a.count}张）` } }) }, options: { canCancle: !1, showMainButtons: !1, thinkPrompt: this.skill.name } } } } }, can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.DamageEvent)) { const { from: e, reason: s, to: r } = t; return "sha" === s && a === e && r.hasCardsInArea() } }, context: (e, a, t) => ({ targets: [t.to] }), cost: async (e, a, t) => (await a.prevent(), !0), async effect (e, a, t) { const { from: s, targets: { 0: r } } = t; let n = 2; for (; n-- > 0;) { t.count = n + 1; const r = await e.doRequest({ player: s, get_selectors: { effectId: this.id, name: "choose", context: t } }), o = e.getResultCards(r); await e.dropCards({ player: s, cards: o, source: a, reason: this.name }) } } })), sgs.loadTranslation({ hanbingjian: "寒冰剑", "@desc:hanbingjian": "装备牌·武器牌\n\n攻击范围：2\n当你因执行你使用的【杀】的效果而对一名角色造成伤害时❷，若其有牌，你可防止此伤害▶你依次弃置其两张牌。", "@hanbingjian": "装备寒冰剑，杀造成伤害时可以改为弃置其两张牌" }); const W = sgs.CardUseEquip({ name: "jueying" }); sgs.setCardData("jueying", { type: 3, subtype: 33, rhyme: "ing" }); const $ = sgs.Skill({ name: "jueying", attached_equip: "jueying" }); $.addEffect(sgs.StateEffect({ [r.Distance_Correct]: F })); const K = sgs.CardUseEquip({ name: "dilu" }); sgs.setCardData("dilu", { type: 3, subtype: 33, rhyme: "u" }); const X = sgs.Skill({ name: "dilu", attached_equip: "dilu" }); X.addEffect(sgs.StateEffect({ [r.Distance_Correct]: F })); const Y = sgs.CardUseEquip({ name: "zhuahuangfeidian" }); sgs.setCardData("zhuahuangfeidian", { type: 3, subtype: 33, rhyme: "an" }); const Q = sgs.Skill({ name: "zhuahuangfeidian", attached_equip: "zhuahuangfeidian" }); Q.addEffect(sgs.StateEffect({ [r.Distance_Correct]: F })); const Z = sgs.CardUseEquip({ name: "chitu" }); sgs.setCardData("chitu", { type: 3, subtype: 34, rhyme: "u" }); const ee = sgs.Skill({ name: "chitu", attached_equip: "chitu" }); ee.addEffect(sgs.StateEffect({ [r.Distance_Correct]: L })); const ae = sgs.CardUseEquip({ name: "dayuan" }); sgs.setCardData("dayuan", { type: 3, subtype: 34, rhyme: "an" }); const te = sgs.Skill({ name: "dayuan", attached_equip: "dayuan" }); te.addEffect(sgs.StateEffect({ [r.Distance_Correct]: L })); const se = sgs.CardUseEquip({ name: "zixin" }); sgs.setCardData("zixin", { type: 3, subtype: 34, rhyme: "in" }); const re = sgs.Skill({ name: "zixin", attached_equip: "zixin" }); re.addEffect(sgs.StateEffect({ [r.Distance_Correct]: L })), sgs.loadTranslation({ jueying: "绝影", "@desc:jueying": "装备牌·防御坐骑\n\n其他角色至你的距离+1。", "@jueying": "装备绝影，其他角色至你的距离+1。", dilu: "的卢", "@desc:dilu": "装备牌·防御坐骑\n\n其他角色至你的距离+1。", "@dilu": "装备的卢，其他角色至你的距离+1。", zhuahuangfeidian: "爪黄飞电", "@desc:zhuahuangfeidian": "装备牌·防御坐骑\n\n其他角色至你的距离+1。", "@zhuahuangfeidian": "装备爪黄飞电，其他角色至你的距离+1。", chitu: "赤兔", "@desc:chitu": "装备牌·进攻坐骑\n\n你至其他角色的距离-1。", "@chitu": "装备赤兔，你至其他角色的距离-1。", dayuan: "大宛", "@desc:dayuan": "装备牌·进攻坐骑\n\n你至其他角色的距离-1。", "@dayuan": "装备大宛，你至其他角色的距离-1。", zixin: "紫骍", "@desc:zixin": "装备牌·进攻坐骑\n\n你至其他角色的距离-1。", "@zixin": "装备紫骍，你至其他角色的距离-1。" }); const ne = sgs.CardUseEquip({ name: "qilingong" }); sgs.setCardData("qilingong", { type: 3, subtype: 31, rhyme: "ong" }); const oe = sgs.Skill({ name: "qilingong", attached_equip: "qilingong" }); oe.addEffect(sgs.StateEffect({ [r.Range_Initial] (e) { if (this.isOwner(e)) return 5 } })), oe.addEffect(sgs.TriggerEffect({ anim: "qilingong_skill", audio: ["qilingong"], auto_log: 1, auto_directline: 1, forced: "cost", priorityType: 2, trigger: "CauseDamage2", getSelectors (e, a) { return { choose: () => { const t = a.from, s = a.targets.at(0); return { selectors: { cards: e.createDropCards(t, { step: 1, count: 1, selecte_type: "rows", selectable: s.getHorses(), data_rows: [{ title: "equipArea", cards: s.getHorses() }], windowOptions: { title: this.skill.name, timebar: e.responseTime, prompt: "麒麟弓：请选择一张牌" } }) }, options: { canCancle: !1, showMainButtons: !1, thinkPrompt: this.skill.name } } } } }, can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.DamageEvent)) { const { from: e, reason: s, to: r } = t; return "sha" === s && a === e && r.getHorses().length > 0 } }, context: (e, a, t) => ({ targets: [t.to] }), async cost (e, a, t) { const { from: s, targets: { 0: r } } = t, n = await e.doRequest({ player: s, get_selectors: { effectId: this.id, name: "choose", context: t } }), o = e.getResultCards(n); return await e.dropCards({ player: s, cards: o, source: a, reason: this.name }) } })), sgs.loadTranslation({ qilingong: "麒麟弓", "@desc:qilingong": "装备牌·武器牌\n\n攻击范围：5\n当你因执行你使用的【杀】的效果而对一名角色造成伤害时❷，你可弃置其装备区里的一张坐骑牌。", "@qilingong": "装备麒麟弓，杀造成伤害时可以弃置其一张坐骑牌", EquipSkill_qilingong: "麒麟弓", "@qilingong_choose": "", "@@qilingong_choose": "麒麟弓", qilingong_chooseone: "麒麟弓：请选择一张牌" }); const ie = sgs.CardUseEquip({ name: "qinggangjian" }); sgs.setCardData("qinggangjian", { type: 3, subtype: 31, rhyme: "an" }); const ce = sgs.Skill({ name: "qinggangjian", attached_equip: "qinggangjian" }); async function ge (e, a) { const t = this.getData("qinggangjian_data"), s = this.getData("qinggangjian_target"), r = a.trigger; t && s ? ("CardEffectStart" === r && a === t && s.invalid && "CardEffectBefore" === s.generator || "BeOffset" === r && a.is(sgs.DataType.UseCardEvent) && a.current === s || "ReduceHpStart" === r && a.is(sgs.DataType.ReduceHpEvent) && a.getDamage().source === t && a.getDamage().source.cast(sgs.DataType.UseCardEvent)?.current === s || "DamageEnd" === r && a.is(sgs.DataType.DamageEvent) && a.source === t && a.source.cast(sgs.DataType.UseCardEvent)?.current === s || "UseCardEnd3" === r && a === t) && (s.target.removeMark("qinggangjian_invalidity"), await this.removeSelf()) : await this.removeSelf() } ce.addEffect(sgs.StateEffect({ [r.Range_Initial] (e) { if (this.isOwner(e)) return 2 } })), ce.addEffect(sgs.TriggerEffect({ anim: "qinggangjian_skill", audio: ["qinggangjian"], auto_log: 1, auto_directline: 1, priorityType: 2, trigger: "AssignTargeted", can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.UseCardEvent)) { const { from: e, card: s } = t; return "sha" === s.name && a === e } }, context: (e, a, t) => ({ targets: [t.current.target] }), cost: async (e, a, t) => !0, async effect (e, a, t) { const { targets: { 0: s } } = t; s.setMark("qinggangjian_invalidity", !0); const r = await e.addEffect("qinggnagjian_end"); r.setData("qinggangjian_data", a), r.setData("qinggangjian_target", a.current) } })), sgs.StateEffect({ name: "qinggnagjian_end", [r.Skill_Invalidity]: e => e.data.attached_equip && 32 === sgs.utils.getCardSubtype(e.data.attached_equip) && e.player && e.player.hasMark("qinggangjian_invalidity"), lifecycle: [{ trigger: "CardEffectStart", priority: "after", on_exec: ge }, { trigger: "BeOffset", priority: "after", on_exec: ge }, { trigger: "ReduceHpStart", priority: "after", on_exec: ge }, { trigger: "DamageEnd", priority: "after", on_exec: ge }, { trigger: "UseCardEnd3", priority: "after", on_exec: ge }] }), sgs.loadTranslation({ qinggangjian: "青釭剑", "@desc:qinggangjian": "装备牌·武器牌\n\n攻击范围：2\n锁定技，当【杀】指定目标后，若使用者为你，你获得1枚“铮”▶你令此目标的角色的防具技能于下列情况之一发生之前无效\n1.对其无效的此【杀】对此目标进行的使用流程结束；\n2.此【杀】被其使用的【闪】抵消；\n3.防止其因执行此牌的效果而造成的伤害；\n4.确定其因执行此牌的效果而造成的伤害的最终的伤害值。", "@qinggangjian": "装备青釭剑，使用杀无视防具" }); const ue = sgs.CardUseEquip({ name: "renwangdun" }); sgs.setCardData("renwangdun", { type: 3, subtype: 32, rhyme: "un" }); const le = sgs.Skill({ name: "renwangdun", attached_equip: "renwangdun" }); le.addEffect(sgs.TriggerEffect({ anim: "renwangdun_skill", audio: ["renwangdun"], auto_log: 1, priorityType: 2, trigger: "CardEffectStart", can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.UseCardEvent)) { const { card: e, current: s } = t; return "sha" === e.name && 2 === e.color && a === s.target } }, cost: async (e, a, t) => (await a.invalidCurrent(), !0) })), sgs.loadTranslation({ renwangdun: "仁王盾", "@desc:renwangdun": "装备牌·防具牌\n\n锁定技，当黑色【杀】对目标的使用结算开始时，若此目标对应的角色为你，你令此【杀】对此目标无效。", "@renwangdun": "装备仁王盾，黑色杀对你无效" }); const de = sgs.CardUseEquip({ name: "tengjia" }); sgs.setCardData("tengjia", { type: 3, subtype: 32, rhyme: "a" }); const he = sgs.Skill({ name: "tengjia", attached_equip: "tengjia" }); he.addEffect(sgs.TriggerEffect({ anim: "tengjia1_skill", audio: ["tengjia"], auto_log: 1, priorityType: 2, trigger: "CardEffectStart", can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.UseCardEvent)) { const { card: e, current: s } = t; return (e.isCommonSha() || "wanjianqifa" === e.name || "nanmanruqin" === e.name) && a === s.target } }, cost: async (e, a, t) => (await a.invalidCurrent(), !0) })), he.addEffect(sgs.TriggerEffect({ anim: "tengjia2_skill", audio: ["tengjia_fire"], auto_log: 1, priorityType: 2, trigger: "InflictDamage2", can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.DamageEvent)) { const { damageType: e, to: s } = t; return 1 === e && a === s } }, cost: async (e, a, t) => (a.number++, !0) })), sgs.loadTranslation({ tengjia: "藤甲", "@desc:tengjia": "装备牌·防具牌\n\n①锁定技，当【南蛮入侵】、【万箭齐发】或普【杀】对目标的使用结算开始时，若此目标对应的角色为你，你令此牌对此目标无效。\n②锁定技，当你受到火焰伤害时❷，你令伤害值+1。", "@tengjia": "装备藤甲，普通杀南蛮和万剑对你无效，但受到火焰伤害+1" }); const pe = sgs.CardUseEquip({ name: "zhuqueyushan" }); sgs.setCardData("zhuqueyushan", { type: 3, subtype: 31, rhyme: "an" }); const fe = sgs.Skill({ name: "zhuqueyushan", attached_equip: "zhuqueyushan" }); fe.addEffect(sgs.StateEffect({ [r.Range_Initial] (e) { if (this.isOwner(e)) return 4 } })), fe.addEffect(sgs.TriggerEffect({ anim: "zhuqueyushan_skill", audio: ["zhuqueyushan"], auto_log: 1, forced: "cost", priorityType: 2, trigger: "DeclareUseCard", can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.UseCardEvent)) { const { from: e, card: s } = t; return s.isCommonSha() && a === e } }, cost: async (e, a, t) => (a.card.sourceData.attr.push(1), !0) })), sgs.loadTranslation({ zhuqueyushan: "朱雀羽扇", "@desc:zhuqueyushan": "装备牌·武器牌\n\n攻击范围：4\n当你声明使用【杀】后，若此【杀】为普【杀】，你可将此【杀】改为火【杀】。", "@zhuqueyushan": "装备朱雀羽扇，使用普通杀可以改为火杀" }); const me = sgs.CardUseEquip({ name: "zhugeliannu" }); sgs.setCardData("zhugeliannu", { type: 3, subtype: 31, rhyme: "u" }); const ye = sgs.Skill({ name: "zhugeliannu", attached_equip: "zhugeliannu" }); ye.addEffect(sgs.StateEffect({ [r.Range_Initial] (e) { if (this.isOwner(e)) return 1 }, [r.TargetMod_PassTimeCheck] (e, a, t) { return this.isOwner(e) && "sha" === a.name } })), ye.addEffect(sgs.TriggerEffect({ anim: "zhugeliannu_skill", audio: ["zhugeliannu"], auto_log: 1, priorityType: 0, trigger: "CardBeUse", can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.UseCardEvent)) { const { from: e, card: s } = t; return "sha" === s.name && a === e && a.getMark("__sha_times") >= 2 } } })), sgs.loadTranslation({ zhugeliannu: "诸葛连弩", "@desc:zhugeliannu": "装备牌·武器牌\n\n攻击范围：1\n锁定技，你使用【杀】无次数的限制。", "@zhugeliannu": "装备诸葛连弩，使用杀无次数限制" }); const _e = sgs.CardUseEquip({ name: "zhangbashemao" }); sgs.setCardData("zhangbashemao", { type: 3, subtype: 31, rhyme: "ao" }); const be = sgs.Skill({ name: "zhangbashemao", attached_equip: "zhangbashemao" }); be.addEffect(sgs.StateEffect({ [r.Range_Initial] (e) { if (this.isOwner(e)) return 3 } })), be.addEffect(sgs.TriggerEffect({ anim: "zhangbashemao_skill", audio: ["zhangbashemao"], priorityType: 2, trigger: "NeedUseCard", auto_log: 1, getSelectors (e, a) { return { skill_cost: () => { const t = a.from, s = e.createVirtualCardByNone("sha", void 0, !1); return s.custom.method = 1, { selectors: { card: e.createChooseCard({ step: 1, count: 2, selectable: t.getHandCards(!0), onChange (e, a) { this._use_or_play_vcard = s } }) }, options: { canCancle: !0, showMainButtons: !0, prompt: "丈八蛇矛：你可以将两张手牌当【杀】使用", thinkPrompt: this.skill.name } } } } }, can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.NeedUseCardData)) return t.from === a && t.has("sha") }, cost: async (e, a, t) => !0 })), be.addEffect(sgs.TriggerEffect({ anim: "zhangbashemao_skill", audio: ["zhangbashemao"], priorityType: 2, trigger: "NeedPlayCard", auto_log: 1, getSelectors (e, a) { return { skill_cost: () => { const t = a.from, s = e.createVirtualCardByNone("sha", void 0, !1); return { selectors: { card: e.createChooseCard({ step: 1, count: 2, selectable: t.getHandCards(!1, !0), onChange (e, a) { this._use_or_play_vcard = s } }) }, options: { canCancle: !0, showMainButtons: !0, prompt: "丈八蛇矛：你可以将两张手牌当【杀】使用", thinkPrompt: this.skill.name } } } } }, can_trigger (e, a, t) { if (this.isOwner(a) && t.is(sgs.DataType.NeedPlayCardData)) return t.from === a && t.has("sha") }, cost: async (e, a, t) => !0 })), sgs.loadTranslation({ zhangbashemao: "丈八蛇矛", "@desc:zhangbashemao": "装备牌·武器牌\n\n攻击范围：3\n当你需要使用/打出普【杀】时❸，你可使用/打出对应的实体牌为你的两张手牌的普【杀】。", "@zhangbashemao": "装备丈八蛇矛，你可以将两张手牌当杀使用或打出" }); const Ce = sgs.Skill({ name: "debug.zuobi", tag: [10] }), we = sgs.TriggerEffect({ name: "zuobi_main", priorityType: 1, trigger: "PlayPhaseProceeding", audio: [], getSelectors: (e, a) => ({ skill_cost: () => ({ selectors: { player: e.createChoosePlayer({ step: 1, count: 1 }), option: e.createChooseOptions({ step: 2, count: 1, selectable: ["zuobi_draw", "zuobi_obtain", "zuobi_change"] }) }, options: { canCancle: !0, showMainButtons: !1, prompt: "zuobi" } }), obtain_card: () => { const a = []; return e.cardNames.forEach((t => { a.push(...e.createVData({ name: t }, !1)) })), { selectors: { card: e.createChooseVCard({ step: 1, count: 1, selectable: a, selecte_type: "win", windowOptions: { title: "", timebar: e.responseTime, prompt: "zuobi_obtain_chooseone" } }) }, options: { canCancle: !0, showMainButtons: !1 } } }, change1: () => ({ selectors: { option: e.createChooseOptions({ step: 1, count: 1, selectable: ["head", "deputy"] }) }, options: { canCancle: !0, showMainButtons: !1, prompt: "zuobi_change" } }), change2: () => { const a = [...e.generals.values()]; return { selectors: { general: e.createChooseGeneral({ step: 1, count: 1, selectable: a, selecte_type: "win", windowOptions: { title: "", timebar: 60, prompt: "zuobi_general_chooseone" } }) }, options: { ms: 60, canCancle: !0, showMainButtons: !1, prompt: "zuobi_change_1" } } } }), can_trigger (e, a, t) { return this.isOwner(a) }, context: (e, a, t) => ({ maxTimes: -1 }), async cost (e, a, t) { const { from: s, req_result: r, targets: { 0: n } } = t, o = r.results.option.result; if (o.includes("zuobi_draw")) return await e.drawCards({ player: n, count: 1, source: a, reason: this.name }); if (o.includes("zuobi_obtain")) { const r = await e.doRequest({ player: s, get_selectors: { effectId: this.id, name: "obtain_card", context: t } }), o = r.result.results?.card?.result?.at(0); if (o && o.name) { const t = e.cards.filter((e => e.name === o.name)), s = t[sgs.utils.randomInt(0, t.length - 1)]; s && await e.obtainCards({ player: n, cards: [s], source: a, reason: this.name }) } } if (o.includes("zuobi_change")) { const r = await e.doRequest({ player: s, get_selectors: { effectId: this.id, name: "change1", context: t } }), o = await e.doRequest({ player: s, get_selectors: { effectId: this.id, name: "change2", context: t } }), i = e.getResult(r, "option").result, c = e.getResult(o, "general").result; i?.length && c?.length && (i.includes("head") && await e.change({ player: n, general: n.head, to_general: c.at(0), source: a, reason: this.name }), i.includes("deputy") && await e.change({ player: n, general: n.deputy, to_general: c.at(0), source: a, reason: this.name })) } } }); Ce.effects.push(we.name), sgs.loadTranslation({ "debug.zuobi": "作弊", "@zuobi": "选择一名角色执行对应效果", zuobi_draw: "摸牌", zuobi_obtain: "获得牌", zuobi_obtain_chooseone: "选择一个牌名，获得一张同名牌", zuobi_change: "变更", "@zuobi_change": "选择变更的位置", zuobi_general_chooseone: "选择一张武将牌" }); const Te = sgs.TriggerEffect({ name: "gamerule_obtain_skill", trigger: "ChooseGeneralAfter", priorityType: 5, can_trigger: () => !0, async cost (e, a) { for (const a of e.playerAlives) { if (a.head) for (const t of a.head.skills) await e.addSkill(t, a, { source: "head_general", showui: "default" }); if (a.deputy) for (const t of a.deputy.skills) await e.addSkill(t, a, { source: "deputy_general", showui: "default" }); e.options.settings.zuobi && await e.addSkill("debug.zuobi", a, { source: "debug", showui: "default" }) } return !0 } }), Ee = sgs.TriggerEffect({ name: "gamerule_init_handcard", trigger: "InitHandCard", priorityType: 5, can_trigger: () => !0, async cost (e, a) { e.drawArea.shuffle(); for (const t of e.players) await e.drawCards({ player: t, count: 4, source: a, reason: this.name, triggerNot: !0 }); return !0 } }), De = sgs.TriggerEffect({ name: "gamerule_judgephase", trigger: "JudgePhaseProceeding", priorityType: 4, can_trigger: (e, a, t) => t.is(sgs.DataType.PhaseEvent) && t.executor === a && a.judgeCards.length > 0, async cost (e, a, t) { const { from: s } = t, r = s.judgeCards.slice(); for (; r.length > 0;)await e.usecardsp({ targets: s, card: r.pop(), source: a, reason: this.name }); return !0 } }), qe = sgs.TriggerEffect({ name: "gamerule_drawphase", trigger: "DrawPhaseProceeding", priorityType: 4, can_trigger: (e, a, t) => t.is(sgs.DataType.PhaseEvent) && t.executor === a && t.ratedDrawnum > 0, async cost (e, a, t) { const { from: s } = t; return await e.drawCards({ player: s, count: a.ratedDrawnum, source: a, reason: this.name }), !0 } }), ve = sgs.TriggerEffect({ name: "gamerule_dropphase", trigger: "DropPhaseProceeding", priorityType: 4, can_trigger: (e, a, t) => t.is(sgs.DataType.PhaseEvent) && t.executor === a && a.getHandCards().length > a.maxhand, getSelectors (e, a) { const t = a.from, s = a.count; return { choose: () => ({ selectors: { card: e.createDropCards(t, { step: 1, count: s, selectable: t.getHandCards() }) }, options: { canCancle: !1, showMainButtons: !0, prompt: { text: "gamerule_dropphase", values: [{ type: "number", value: s }] } } }) } }, async cost (e, a, t) { const { from: s } = t, r = s.handArea.count - s.maxhand; t.count = r; const n = (await e.doRequest({ player: s, get_selectors: { effectId: this.id, name: "choose", context: t } })).result.results.card.result; return await e.dropCards({ player: s, cards: n, source: a, reason: this.name }), !0 } }); sgs.loadTranslation({ "@gamerule_dropphase": "弃牌阶段，你需要弃置{0}张牌", "@@gamerule_dropphase": "弃牌阶段" }), e.baguazhen = M, e.baguazhen_skill = O, e.baiyin_effect_delay = B, e.baiyinshizi = R, e.baiyinshizi_skill = I, e.base_selectors = t, e.bingliangcunduan = d, e.chitu = Z, e.chitu_skill = ee, e.cixiong_skill = H, e.cixiongshuanggujian = A, e.dayuan = ae, e.dayuan_skill = te, e.dilu = K, e.dilu_skill = X, e.gamerule_drawphase = qe, e.gamerule_dropphase = ve, e.gamerule_init_handcard = Ee, e.gamerule_judgephase = De, e.gamerule_obtain_skill = Te, e.guanshi_skill = J, e.guanshifu = N, e.guohechaiqiao = p, e.guohechaiqiao_choose = h, e.hanbing_skill = V, e.hanbingjian = G, e.huogong = m, e.huogong_choose = f, e.jiedaosharen = _, e.jiedaosharen_choose = y, e.jiu = g, e.jiu2 = u, e.juedou = b, e.jueying = W, e.jueying_skill = $, e.lebusishu = C, e.main = we, e.nanmanruqin = w, e.qilingong = ne, e.qilingong_skill = oe, e.qinggangjian = ie, e.qinggangjian_skill = ce, e.renwangdun = ue, e.renwangdun_skill = le, e.sha = n, e.shan = o, e.shandian = E, e.shunshouqianyang = q, e.shunshouqianyang_choose = D, e.tao = i, e.tao2 = c, e.taoyuanjieyi = j, e.tengjia = de, e.tengjia_skill = he, e.tiesuolianhuan = k, e.wanjianqifa = P, e.wugufengdeng = S, e.wuxiekeji = U, e.wuzhongshengyou = l, e.zhangba = _e, e.zhangba_skill = be, e.zhuahuangfeidian = Y, e.zhuahuangfeidian_skill = Q, e.zhugeliannu = me, e.zhugeliannu_skill = ye, e.zhuque = pe, e.zhuque_skill = fe, e.zixin = se, e.zixin_skill = re, e.zuobi = Ce }({});
