# 卡牌类型体系

<cite>
**本文档引用文件**  
- [card.types.ts](file://server/src/core/card/card.types.ts)
- [icard.ts](file://server/src/core/card/icard.ts)
- [vcard.ts](file://server/src/core/card/vcard.ts)
- [sgs.ts](file://server/src/core/sgs.ts)
- [room.card.js](file://server/build/core/room/mixins/room.card.js)
</cite>

## 目录
1. [引言](#引言)
2. [卡牌分类体系](#卡牌分类体系)
3. [卡牌类型枚举设计](#卡牌类型枚举设计)
4. [卡牌类型继承关系](#卡牌类型继承关系)
5. [卡牌功能实现分析](#卡牌功能实现分析)
6. [虚拟卡牌系统](#虚拟卡牌系统)
7. [类型安全机制](#类型安全机制)

## 引言

卡牌类型体系是resgsv1游戏核心逻辑的重要组成部分，负责定义和管理游戏中所有卡牌的分类、属性和行为。本系统采用TypeScript的强类型特性，通过枚举和接口构建了一个结构清晰、类型安全的卡牌分类体系。该体系不仅支持基本牌、锦囊牌和装备牌三大类别的划分，还实现了精细化的子类型管理，为游戏规则的执行提供了坚实的基础。

**Section sources**
- [card.types.ts](file://server/src/core/card/card.types.ts#L1-L160)

## 卡牌分类体系

resgsv1的卡牌系统采用多层级分类结构，将卡牌划分为三个主要类别：基本牌、锦囊牌和装备牌。每个主类别下又细分为不同的子类型，形成完整的分类树。

### 基本牌
基本牌是游戏中最基础的卡牌类型，主要包括：
- **杀**：攻击类卡牌，用于对其他角色造成伤害
- **闪**：防御类卡牌，用于抵消"杀"的攻击
- **桃**：恢复类卡牌，用于恢复生命值

### 装备牌
装备牌分为多个子类别，提供持续性的能力加成：
- **武器**：增强攻击范围和能力
- **防具**：提供防御保护
- **坐骑**：分为进攻坐骑和防御坐骑，影响角色的攻防距离
- **宝物**：提供特殊能力的装备

### 锦囊牌
锦囊牌分为两类：
- **非延时锦囊牌**：立即生效的特殊效果卡牌
- **延时锦囊牌**：需要放置在角色面前，满足条件后才触发效果

**Section sources**
- [card.types.ts](file://server/src/core/card/card.types.ts#L50-L100)

## 卡牌类型枚举设计

卡牌类型体系通过一系列TypeScript枚举实现类型定义，确保了类型安全和代码可维护性。

### 主要枚举类型

```typescript
/** 卡牌类别 */
export const enum CardType {
    None = 0,
    /** 基本牌 */
    Basic = 1,
    /** 锦囊牌 */
    Scroll = 2,
    /** 装备牌 */
    Equip = 3,
}

/** 装备牌副类别 */
export const enum EquipSubType {
    None = 0,
    /** 武器 */
    Weapon = 31,
    /** 防具 */
    Armor = 32,
    /** 防御坐骑 */
    DefensiveMount = 33,
    /** 进攻坐骑 */
    OffensiveMount = 34,
    /** 特殊坐骑 */
    SpecialMount = 35,
    /** 宝物 */
    Treasure = 36,
}

/** 卡牌副类别 */
export const enum CardSubType {
    None = 0,
    /** 基本牌 */
    Basic = 1,
    /** 非延时锦囊牌 */
    InstantScroll = 21,
    /** 延时锦囊牌 */
    DelayedScroll = 22,
    /** 武器 */
    Weapon = 31,
    /** 防具 */
    Armor = 32,
    /** 防御坐骑 */
    DefensiveMount = 33,
    /** 进攻坐骑 */
    OffensiveMount = 34,
    /** 特殊坐骑 */
    SpecialMount = 35,
    /** 宝物 */
    Treasure = 36,
}
```

### 枚举设计特点

1. **数值编码策略**：采用数字编码，主类型和子类型通过数值范围区分，如装备类从30开始
2. **类型安全**：使用`const enum`确保编译时类型检查，减少运行时错误
3. **扩展性**：预留数值空间，便于未来扩展新的卡牌类型
4. **语义化**：通过注释明确每个枚举值的含义

这种设计使得卡牌类型的判断和转换既高效又安全，为游戏逻辑的实现提供了可靠的基础。

**Section sources**
- [card.types.ts](file://server/src/core/card/card.types.ts#L50-L100)

## 卡牌类型继承关系

卡牌系统通过类继承和接口实现构建了清晰的对象关系模型。

### 类图展示

```mermaid
classDiagram
class ICard {
+string name
+CardSuit suit
+CardNumber number
+CardColor color
+CardAttr[] attr
+CardType type
+CardSubType subtype
+hasAttr(attr : CardAttr) bool
+isCommonSha() bool
+isDamageCard() bool
+isHorse() bool
}
class GameCard {
+GameCardId id
+boolean derived
+string package
}
class VirtualCard {
+VirtualCardId id
+GameCard[] subcards
+{ [key : string] : any } custom
+get vdata() : VirtualCardData
+hasSubCards() bool
}
ICard <|-- GameCard
ICard <|-- VirtualCard
GameCard --> CardType
GameCard --> CardSubType
VirtualCard --> SourceData
```

**Diagram sources**
- [icard.ts](file://server/src/core/card/icard.ts#L0-L46)
- [vcard.ts](file://server/src/core/card/vcard.ts#L0-L223)

### 继承关系分析

1. **ICard接口**：定义了卡牌的基本属性和方法，作为所有卡牌类型的基类
2. **GameCard实体卡牌**：继承ICard，包含具体的卡牌ID、所属扩展包等信息
3. **VirtualCard虚拟卡牌**：继承ICard，用于表示由多张实体卡牌组合而成的虚拟卡牌

这种继承结构实现了代码复用，同时保持了类型系统的完整性。`ICard`类中的`type`和`subtype`属性通过`sgs.utils.getCardType`和`sgs.utils.getCardSubtype`方法动态获取，确保了类型判断的准确性。

**Section sources**
- [icard.ts](file://server/src/core/card/icard.ts#L0-L46)
- [vcard.ts](file://server/src/core/card/vcard.ts#L0-L223)

## 卡牌功能实现分析

### 桃的生命恢复效果

"桃"作为基本牌中的恢复类卡牌，其生命恢复效果通过游戏事件系统实现。当玩家使用"桃"时，会触发`RecoverHpEvent`事件，调用`RecoverHpEvent`处理器增加目标角色的生命值。

```typescript
// 在sgs.ts中定义生命恢复事件
export const sgs = RESGS.getInstance();
// 通过事件系统处理生命恢复
const recoverEvent = new RecoverHpEvent(target, source, 1);
room.handleEvent(recoverEvent);
```

### 闪的防御机制

"闪"的防御机制通过条件判断和事件拦截实现。当有"杀"攻击时，系统会检查目标角色是否拥有"闪"卡牌，并允许其使用"闪"来抵消伤害。

```typescript
// 在ICard类中定义防御判断
public isCommonSha() {
    return (
        this.name === 'sha' &&
        !this.attr.includes(CardAttr.Fire) &&
        !this.attr.includes(CardAttr.Thunder)
    );
}
```

### 八卦阵的判定效果

"八卦阵"作为防具类装备，其判定效果通过特殊的判定机制实现。当装备"八卦阵"的角色受到攻击时，会触发额外的花色判定，根据判定结果决定是否抵消伤害。

```typescript
// 通过卡牌属性实现特殊效果
export const enum CardAttr {
    /** 火属性 杀专属*/
    Fire = 1,
    /** 雷属性 杀专属*/
    Thunder,
    /** 国属性 国战无懈可击专属 */
    Country,
    /** 可重铸 */
    Recastable,
    /** 可合纵 */
    Transferable,
    /** 鏖战 */
    Aozhan,
}
```

### 无懈可击的反制逻辑

"无懈可击"作为特殊的锦囊牌，其反制逻辑通过递归式的反制机制实现。任何锦囊牌效果都可以被"无懈可击"反制，而"无懈可击"本身也可以被另一张"无懈可击"反制，形成"无懈-无懈"的对抗链。

```typescript
// 在sgs.ts中设置卡牌数据
public setCardData(
    card: string,
    {
        type = CardType.Basic,
        subtype = CardSubType.Basic,
        damage = false,
        recover = false,
        length = 1,
        rhyme = 'a',
    }: Partial<{
        type: CardType;
        subtype: CardSubType;
        damage: boolean;
        recover: boolean;
        length: number;
        rhyme: string;
    }> = {}
) {
    this.card2datas[card] = arguments[1];
}
```

**Section sources**
- [icard.ts](file://server/src/core/card/icard.ts#L0-L46)
- [sgs.ts](file://server/src/core/sgs.ts#L800-L990)

## 虚拟卡牌系统

虚拟卡牌系统是resgsv1中处理复合卡牌效果的核心机制，用于表示由多张实体卡牌组合而成的特殊卡牌。

### 虚拟卡牌创建

虚拟卡牌通过`RoomCardMixin`中的方法创建：

```typescript
/** 创建一张实体牌对应的虚拟牌
 * @param card 实体牌
 */
createVirtualCardByOne(card, record = true) {
    const vcard = new VirtualCard(`01${this.vcardids++}`, this, card.name, [card], record);
    if (record)
        this._createVirtualCard(vcard);
    return vcard;
}

/** 创建一张无实体牌的虚拟牌,并指定其默认属性
 * @param name 牌名
 * @param property 牌的属性
 */
createVirtualCardByNone(name, property = {}, record = true) {
    const vcard = new VirtualCard(`01${this.vcardids++}`, this, name, [], record);
    vcard.set(property);
    if (record)
        this._createVirtualCard(vcard);
    return vcard;
}
```

### 属性继承机制

虚拟卡牌的属性继承遵循特定规则：
- **花色**：如果只有一张子卡牌，则继承其花色；否则为无花色
- **颜色**：根据子卡牌的花色统一确定，全黑为黑色，全红为红色，混合为无色
- **点数**：如果只有一张子卡牌，则继承其点数；否则为无点数
- **属性**：继承第一张子卡牌的所有属性

```typescript
protected defaultColor() {
    if (this.subcards.length === 0)
        return sgs.utils.getColorBySuit(this.sourceData.suit);
    else if (this.subcards.length === 1) return this.subcards[0].color;
    else {
        if (
            this.subcards.every(
                (v) => v.suit === CardSuit.Club || v.suit === CardSuit.Spade
            )
        ) {
            return CardColor.Black;
        } else if (
            this.subcards.every(
                (v) =>
                    v.suit === CardSuit.Diamond || v.suit === CardSuit.Heart
            )
        ) {
            return CardColor.Red;
        } else {
            return CardColor.None;
        }
    }
}
```

**Section sources**
- [vcard.ts](file://server/src/core/card/vcard.ts#L133-L180)
- [room.card.js](file://server/build/core/room/mixins/room.card.js#L35-L70)

## 类型安全机制

resgsv1通过TypeScript的类型系统和运行时检查相结合的方式，确保了卡牌类型的安全性。

### 编译时类型检查

通过TypeScript的接口和枚举定义，实现了严格的编译时类型检查：

```typescript
export interface GameCardData {
    id: GameCardId;
    /** 卡牌名 */
    name: string;
    /** 花色 */
    suit: CardSuit;
    /** 颜色 */
    color?: CardColor;
    /** 点数 */
    number: CardNumber;
    /** 属性 */
    attr: CardAttr[];
    /** 是否为衍生牌 */
    derived: boolean;
    /** 所属扩展包 */
    package: string;
}
```

### 运行时类型验证

在游戏运行时，通过`sgs.utils`工具类进行类型验证和转换：

```typescript
public get type() {
    return sgs.utils.getCardType(this.name);
}

public get subtype() {
    return sgs.utils.getCardSubtype(this.name);
}
```

### 类型映射表

系统维护了一个卡牌数据映射表，用于快速查询卡牌的类型信息：

```typescript
public card2datas: {
    [key: string]: {
        type: CardType;
        subtype: CardSubType;
        damage: boolean;
        recover: boolean;
        length: number;
        rhyme: string;
    };
} = {};

public setCardData(
    card: string,
    {
        type = CardType.Basic,
        subtype = CardSubType.Basic,
        damage = false,
        recover = false,
        length = 1,
        rhyme = 'a',
    }: Partial<{
        type: CardType;
        subtype: CardSubType;
        damage: boolean;
        recover: boolean;
        length: number;
        rhyme: string;
    }> = {}
) {
    this.card2datas[card] = arguments[1];
}
```

这种双重保障机制确保了卡牌类型在编译和运行时都保持一致，有效防止了类型错误导致的游戏异常。

**Section sources**
- [card.types.ts](file://server/src/core/card/card.types.ts#L1-L160)
- [sgs.ts](file://server/src/core/sgs.ts#L800-L990)